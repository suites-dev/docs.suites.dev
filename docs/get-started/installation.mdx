---
sidebar_position: 3
title: Installation
description: Learn how to install and configure Suites to enhance your unit testing process across various DI frameworksand testing libraries.
---

## Prerequisites

:::warning Node.js Version Requirement
Suites v4.0.0+ requires **Node.js 20 or higher**. Check your version with `node --version`.
:::

- Node.js 20 or higher
- TypeScript project with decorators enabled
- A dependency injection framework (NestJS or InversifyJS)
- A testing library (Jest, Vitest, or Sinon)

## Installation

:::tip Testing Beta?
For v4.0.0 beta with boundaries and fail-fast features, see [Changelog](/docs/changelog) for beta installation instructions.
:::

Install Suites' core package:

```bash
npm install -D @suites/unit
```

Install the adapters for your DI framework and testing library:

```bash
# Example: Jest + NestJS
npm install -D @suites/doubles.jest @suites/di.nestjs
```

Complete setup examples available in the [Suites Examples](https://github.com/suites-dev/examples) repository.

Lastly, make sure `reflect-metadata` is also installed in your project, not as a dev dependency ([Why?](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata)):

```bash
$ npm i reflect-metadata
```

Suites will automatically detect the installed adapters and configure itself accordingly.

## Supported Libraries

### Available Dependency Injection Adapters:

- `@suites/di.nestjs`
- `@suites/di.inversify`

### Available Mocking Libraries Adapters:

- `@suites/doubles.jest`
- `@suites/doubles.sinon`
- `@suites/doubles.vitest`

After installation, no additional configuration for the test runner is needed.

## Setting Up `tsconfig.json`

In order to use Suites, you need to enable the [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) and [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) options in your `tsconfig.json` file.
This configuration is necessary for Suites to reflect class dependencies and to work with dependency injection frameworks.

```json title="tsconfig.json"
{
  "compilerOptions": {
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true
  }
}
```

:::tip NodeNext Module Resolution
Suites v4.0.0+ fully supports `"module": "NodeNext"` in your `tsconfig.json`, providing better ESM compatibility and modern module resolution.
:::

## Type Reference Configuration

To ensure type safety and maintain a clean API, Suites requires setting up type references for your mocking library. This approach enables importing all utilities from `@suites/unit` while maintaining proper type information.

### Setting Up Type References

1. **Create a `global.d.ts` file** in your project's root directory (or the location specified as `rootDir` in your `tsconfig.json`).

2. **Add reference types** for your mocking library AND DI framework:

```typescript title="global.d.ts"
// Mocking library (choose one)
/// <reference types="@suites/doubles.jest/unit" />
// OR
/// <reference types="@suites/doubles.sinon/unit" />
// OR
/// <reference types="@suites/doubles.vitest/unit" />

// DI framework (choose one)
/// <reference types="@suites/di.nestjs" />
// OR
/// <reference types="@suites/di.inversify" />
```

**Example for Jest + NestJS:**
```typescript title="global.d.ts"
/// <reference types="@suites/doubles.jest/unit" />
/// <reference types="@suites/di.nestjs" />
```

This configuration ensures your project correctly recognizes the types provided by Suites (like the `Mocked<T>` type) without needing to import them from library-specific modules.

## Monorepo Support

Suites is fully compatible with monorepo setups, accommodating projects that use different mocking or DI frameworks.

### Recommended Setups

When using Suites in a monorepo, consider the following setups:

**Using the same mocking and DI framework across all workspaces** \
Install the corresponding adapter under the root directory of your monorepo.
Suites will automatically detect the adapter and configure itself accordingly.

**Using different frameworks across workspaces** \
Install the corresponding adapter in each workspace separately. Make sure to configure your package manager's hoisting settings
to enable Suites to detect the adapter in each workspace.

:::note
Some package managers may have limitations with dependency hoisting that can affect using different DI or mocking libraries
across workspaces. Please refer to your package manager's documentation for specific guidance on dependency hoisting.
:::

## For Vitest Users

When integrating Suites with Vitest, additional configuration is required. Vitest typically uses [`esbuild`](https://esbuild.github.io/) for
TypeScript interpretation, which doesn't support `emitDecoratorMetadata` - a feature extensively used by Suites for
reflecting class dependencies. To overcome this, switch to using [`@swc/core`](https://swc.rs/docs/usage/core) via a
plugin, which supports `emitDecoratorMetadata`. For detailed guidance, see the [Vitest documentation](https://vitest.dev/).

Here is an example of how to configure Suites with Vitest:

First, install the `unplugin-swc` and `@swc/core` packages and add it to your `vitest.config.ts` file as a plugin.
This will enable `@swc/core` to interpret TypeScript files and support `emitDecoratorMetadata`.

```bash
$ npm install --save-dev unplugin-swc @swc/core
```

```typescript title="vitest.config.ts"
import swc from "unplugin-swc";
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: { globals: true, root: "./" },
  plugins: [swc.vite({ module: { type: "es6" } })],
});
```

<div class="next-steps-section">

## What's Next?

After installing Suites, you can start writing your first test.
Check out the [Quick Start](/docs/get-started/quickstart) guide to write your first test, or explore the [Guides](/docs/guides/) section for testing patterns.

</div>
